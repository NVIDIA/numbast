# SPDX-FileCopyrightText: Copyright (c) 2024 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
# SPDX-License-Identifier: Apache-2.0

import subprocess
import os
import tempfile

import pylibastcanopy as bindings

from ast_canopy.decl import Function, Struct, ClassTemplate


def make_ast_from_source(
    source_file_path: str,
    compute_capability: str,
    cccl_root: str = "",
    cudatoolkit_include_dir: str = "/usr/local/cuda/include/",
    cxx_standard="c++17",
) -> str:
    """Given a source file path, make an AST file in a temp directory and return the path to it.

    Parameters
    ----------
    source_file_path : str
        The path to the source file to parse.
    compute_capability : str
        The CUDA compute capability (e.g. sm_80) to use for the parsing.
    cccl_root : str
        The path to the CCCL root directory. This settings is used when
        developer would like to use a custom CCCL version over the one
        provided in CTK. The CCCL root will be expanded to include the
        libcudacxx, cub and thrust include directories. These include
        directories will precede the `cudatoolkit_include_dir` specified
        below. (If none, the default CCCL in CTK will be used.)
        Default to "".
    cudatoolkit_include_dir : str
        The path to the CUDA toolkit include directory.
        Default to "/usr/local/cuda/include/".
    cxx_standard : str
        The C++ standard to use for the parsing.
        Default to "c++17".

    Returns
    -------
    Path to the AST file : str
    """

    if cccl_root:
        cccl_libs = [
            os.path.join(cccl_root, "libcudacxx", "include"),
            os.path.join(cccl_root, "cub"),
            os.path.join(cccl_root, "thrust"),
        ]
        cccl_libs = [f"-I{lib}" for lib in cccl_libs]
    else:
        cccl_libs = []

    tmp_folder = tempfile.gettempdir()
    subprocess.run(
        [
            "clang++",
            "-xcuda",
            f"--cuda-gpu-arch={compute_capability}",
            f"-std={cxx_standard}",
            "-I/usr/include/c++/11/",
            "-I/usr/include/x86_64-linux-gnu/c++/11/",
            "-I/usr/lib/gcc/x86_64-linux-gnu/11/include",
            "-I/usr/include/",  # /usr/include must be last in the include list
            *cccl_libs,
            f"-I{cudatoolkit_include_dir}",
            "-emit-ast",
            source_file_path,
        ],
        cwd=tmp_folder,
    )

    source_base_name = os.path.basename(source_file_path)
    ast_name = source_base_name.split(".")[0] + ".ast"
    tmp_ast_path = os.path.join(tmp_folder, ast_name)

    return tmp_ast_path


def parse_declarations_from_ast(
    ast_file_path: str, files_to_retain: list[str]
) -> tuple[
    list[Struct],
    list[Function],
    list[bindings.FunctionTemplate],
    list[ClassTemplate],
    list[bindings.Typedef],
    list[bindings.Enum],
]:
    """Parse the AST file generated by `make_ast_from_source`.

    Parameters
    ----------
    ast_file_path : str
        The path to the AST file to parse.
    files_to_retain : list[str]
        A list of source files to keep in the parsing. CUDA ASTs usually contains more headers
        that one want to look at. This list keeps the parsing focused only on files that are specified.

    Returns
    -------
    structs : list[Struct]
        A list of Struct objects.
    functions : list[Function]
        A list of Function objects.
    function_templates : list[FunctionTemplate]
        A list of bindings.FunctionTemplate objects.
    class_templates : list[ClassTemplate]
        A list of bindings.ClassTemplate objects.
    typedefs : list[Typedef]
        A list of bindings.Typedef objects.
    enums : list[Enum]
        A list of bindings.Enum objects.
    """
    decls = bindings.parse_declarations_from_ast(ast_file_path, files_to_retain)
    structs = [Struct.from_c_obj(c_obj) for c_obj in decls.records]
    functions = [Function.from_c_obj(c_obj) for c_obj in decls.functions]
    class_templates = [
        ClassTemplate.from_c_obj(c_obj) for c_obj in decls.class_templates
    ]

    return (
        structs,
        functions,
        decls.function_templates,
        class_templates,
        decls.typedefs,
        decls.enums,
    )


def parse_declarations_from_source(
    source_file_path: str,
    files_to_retain: list[str],
    compute_capability: str,
    cccl_root: str = "",
    cudatoolkit_include_dir: str = "/usr/local/cuda/include/",
    cxx_standard="c++17",
) -> tuple[
    list[Struct],
    list[Function],
    list[bindings.FunctionTemplate],
    list[ClassTemplate],
    list[bindings.Typedef],
    list[bindings.Enum],
]:
    if cccl_root:
        cccl_libs = [
            os.path.join(cccl_root, "libcudacxx", "include"),
            os.path.join(cccl_root, "cub"),
            os.path.join(cccl_root, "thrust"),
        ]
        cccl_libs = [f"-I{lib}" for lib in cccl_libs]
    else:
        cccl_libs = []

    clang_resource_file = (
        subprocess.check_output(["clang++", "-print-resource-dir"]).decode().strip()
    )

    command_line_options = [
        "clang++",
        "-xcuda",
        f"--cuda-gpu-arch={compute_capability}",
        f"-std={cxx_standard}",
        f"-isystem{clang_resource_file}/include/",
        "-I/usr/include/c++/11/",
        "-I/usr/include/x86_64-linux-gnu/c++/11/",
        "-I/usr/lib/gcc/x86_64-linux-gnu/11/include",
        "-I/usr/include/",  # /usr/include must be last in the include list
        *cccl_libs,
        f"-I{cudatoolkit_include_dir}",
        source_file_path,
    ]

    decls = bindings.parse_declarations_from_command_line(
        command_line_options, files_to_retain
    )
    structs = [Struct.from_c_obj(c_obj) for c_obj in decls.records]
    functions = [Function.from_c_obj(c_obj) for c_obj in decls.functions]
    class_templates = [
        ClassTemplate.from_c_obj(c_obj) for c_obj in decls.class_templates
    ]

    return (
        structs,
        functions,
        decls.function_templates,
        class_templates,
        decls.typedefs,
        decls.enums,
    )
