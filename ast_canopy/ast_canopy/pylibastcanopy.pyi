from _typeshed import Incomplete
from typing import ClassVar, overload

class ClassTemplate(Template):
    num_min_required_args: int
    record: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...

class ConstExprVar:
    name: str
    type_: Type
    value: str
    def __init__(self) -> None: ...

class Declarations:
    class_templates: list[ClassTemplate]
    enums: list[Enum]
    function_templates: list[FunctionTemplate]
    functions: list[Function]
    records: list[Record]
    typedefs: list[Typedef]
    def __init__(self, *args, **kwargs) -> None: ...

class Enum:
    enumerator_values: list[str]
    enumerators: list[str]
    name: str
    def __init__(self, arg0) -> None: ...

class Field:
    access: access_kind
    name: str
    type_: Type
    def __init__(self, *args, **kwargs) -> None: ...

class Function:
    exec_space: execution_space
    is_constexpr: bool
    mangled_name: str
    name: str
    params: list[ParamVar]
    return_type: Type
    def __init__(self, *args, **kwargs) -> None: ...

class FunctionTemplate(Template):
    function: Function
    num_min_required_args: int
    def __init__(self, *args, **kwargs) -> None: ...

class Method(Function):
    kind: method_kind
    def __init__(self, *args, **kwargs) -> None: ...
    def is_move_constructor(self) -> bool: ...

class ParamVar:
    name: str
    type_: Type
    def __init__(self, arg0: str, arg1: Type) -> None: ...

class ParseError(Exception): ...

class Record:
    alignof_: int
    fields: list[Field]
    methods: list[Method]
    name: str
    nested_class_templates: list[ClassTemplate]
    nested_records: list[Record]
    sizeof_: int
    templated_methods: list[FunctionTemplate]
    def __init__(self, *args, **kwargs) -> None: ...

class Template:
    num_min_required_args: int
    template_parameters: list[TemplateParam]
    def __init__(self, arg0: list[TemplateParam], arg1: int) -> None: ...

class TemplateParam:
    kind: template_param_kind
    name: str
    type_: Type
    def __init__(self, *args, **kwargs) -> None: ...

class Type:
    name: str
    unqualified_non_ref_type_name: str
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(
        self, arg0: str, arg1: str, arg2: bool, arg3: bool
    ) -> None: ...
    def is_left_reference(self) -> bool: ...
    def is_right_reference(self) -> bool: ...

class Typedef:
    name: str
    underlying_name: str
    def __init__(self, *args, **kwargs) -> None: ...

class access_kind:
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    private_: ClassVar[access_kind] = ...
    protected_: ClassVar[access_kind] = ...
    public_: ClassVar[access_kind] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class execution_space:
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    device: ClassVar[execution_space] = ...
    global_: ClassVar[execution_space] = ...
    host: ClassVar[execution_space] = ...
    host_device: ClassVar[execution_space] = ...
    undefined: ClassVar[execution_space] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class method_kind:
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    conversion_function: ClassVar[method_kind] = ...
    converting_constructor: ClassVar[method_kind] = ...
    copy_constructor: ClassVar[method_kind] = ...
    default_constructor: ClassVar[method_kind] = ...
    destructor: ClassVar[method_kind] = ...
    move_constructor: ClassVar[method_kind] = ...
    other: ClassVar[method_kind] = ...
    other_constructor: ClassVar[method_kind] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class template_param_kind:
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    non_type: ClassVar[template_param_kind] = ...
    template_: ClassVar[template_param_kind] = ...
    type_: ClassVar[template_param_kind] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

def parse_declarations_from_command_line(
    arg0: list[str], arg1: list[str]
) -> Declarations: ...
def value_from_constexpr_vardecl(
    arg0: list[str], arg1: str
) -> ConstExprVar | None: ...
