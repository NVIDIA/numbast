from _typeshed import Incomplete
from typing import ClassVar, overload

class ClassTemplate(Decl, Template):
    num_min_required_args: int
    record: Incomplete
    def __init__(self, *args, **kwargs) -> None: ...

class ConstExprVar(Decl):
    name: str
    type_: Type
    value: str
    def __init__(self) -> None: ...

class Decl:
    source_location: SourceLocation
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0) -> None: ...

class Declarations:
    class_templates: list[ClassTemplate]
    enums: list[Enum]
    function_templates: list[FunctionTemplate]
    functions: list[Function]
    records: list[Record]
    typedefs: list[Typedef]
    def __init__(self, *args, **kwargs) -> None: ...

class Enum(Decl):
    enumerator_values: list[str]
    enumerators: list[str]
    name: str
    def __init__(self, arg0) -> None: ...

class Field(Decl):
    access: access_kind
    name: str
    type_: Type
    def __init__(self, *args, **kwargs) -> None: ...

class Function(Decl):
    exec_space: execution_space
    is_constexpr: bool
    mangled_name: str
    name: str
    params: list[ParamVar]
    return_type: Type
    def __init__(self, *args, **kwargs) -> None: ...

class FunctionTemplate(Decl, Template):
    function: Function
    num_min_required_args: int
    def __init__(self, *args, **kwargs) -> None: ...

class Method(Function):
    kind: method_kind
    def __init__(self, *args, **kwargs) -> None: ...
    def is_move_constructor(self) -> bool: ...

class ParamVar(Decl):
    name: str
    type_: Type
    def __init__(self, arg0: str, arg1: Type) -> None: ...

class ParseError(Exception): ...

class Record(Decl):
    alignof_: int
    fields: list[Field]
    methods: list[Method]
    name: str
    nested_class_templates: list[ClassTemplate]
    nested_records: list[Record]
    sizeof_: int
    templated_methods: list[FunctionTemplate]
    def __init__(self, *args, **kwargs) -> None: ...

class SourceLocation:
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: str, arg1: int, arg2: int, arg3: bool) -> None: ...
    @property
    def column(self) -> int: ...
    @property
    def file_name(self) -> str: ...
    @property
    def is_valid(self) -> bool: ...
    @property
    def line(self) -> int: ...

class Template:
    num_min_required_args: int
    template_parameters: list[TemplateParam]
    def __init__(self, arg0: list[TemplateParam], arg1: int) -> None: ...

class TemplateParam(Decl):
    kind: template_param_kind
    name: str
    type_: Type
    def __init__(self, *args, **kwargs) -> None: ...

class Type:
    name: str
    unqualified_non_ref_type_name: str
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(
        self, arg0: str, arg1: str, arg2: bool, arg3: bool
    ) -> None: ...
    def is_left_reference(self) -> bool: ...
    def is_right_reference(self) -> bool: ...

class Typedef(Decl):
    name: str
    underlying_name: str
    def __init__(self, *args, **kwargs) -> None: ...

class access_kind:
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    private_: ClassVar[access_kind] = ...
    protected_: ClassVar[access_kind] = ...
    public_: ClassVar[access_kind] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class execution_space:
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    device: ClassVar[execution_space] = ...
    global_: ClassVar[execution_space] = ...
    host: ClassVar[execution_space] = ...
    host_device: ClassVar[execution_space] = ...
    undefined: ClassVar[execution_space] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class method_kind:
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    conversion_function: ClassVar[method_kind] = ...
    copy_constructor: ClassVar[method_kind] = ...
    default_constructor: ClassVar[method_kind] = ...
    destructor: ClassVar[method_kind] = ...
    move_constructor: ClassVar[method_kind] = ...
    other: ClassVar[method_kind] = ...
    other_constructor: ClassVar[method_kind] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class template_param_kind:
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    non_type: ClassVar[template_param_kind] = ...
    template_: ClassVar[template_param_kind] = ...
    type_: ClassVar[template_param_kind] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

def parse_declarations_from_command_line(
    arg0: list[str], arg1: list[str], arg2: list[str]
) -> Declarations: ...
def value_from_constexpr_vardecl(
    arg0: list[str], arg1: str
) -> ConstExprVar | None: ...
